{"version":3,"sources":["js/CV/CVwebworker.js"],"names":["cityIOdataStruct","CV","scannedPixels","threshold","pixColArr","typesArray","webworkerMsg","i","length","avg_0","avg_1","avg_2","avg","push","pixelCol","typesLookup","pixelColorArray","thisBrick","j","join","indexCode","objects","codes","indexOf","includes","checkRotatedBrick","postMessage","newIndex","shiftedString","slice","self","addEventListener","msg","data","log","header","name"],"mappings":";AACA,IAAIA,EAkBJ,SAASC,EAAGC,GAYL,IATDC,IAEAC,EAAY,GAEZC,EAAa,GAEbC,EAAe,GAGVC,EAAI,EAAGA,EAAIL,EAAcM,OAAQD,IAEtC,MAAA,IAAOL,EAAcK,GAAG,GACxB,IAAOL,EAAcK,GAAG,GACxB,IAAOL,EAAcK,GAAG,GAExB,MAAA,IAAOL,EAAcK,GAAG,GACxB,IAAOL,EAAcK,GAAG,GACxB,IAAOL,EAAcK,GAAG,GAExB,MAAA,IAAOL,EAAcK,GAAG,GACxB,IAAOL,EAAcK,GAAG,GACxB,IAAOL,EAAcK,GAAG,GAEpB,KAACE,MAAQC,MAAQC,OAAS,EAG5BC,IAAM,IAEG,SAAA,EACFA,IAAM,IAEJ,SAAA,EAGA,SAAA,EAEHC,EAAAA,KAAKC,UAmCJD,EAAAA,KA9BJE,SAAYC,GAId,IAAA,IAAIT,EAAI,EAAGA,EAAIH,EAAUI,OAAQD,GAAQ,GAAI,CAE3C,IADDU,IAAAA,EAAY,GACPC,EAAI,EAAGA,EAAI,GAAIA,IACZL,EAAAA,KAAKG,EAAgBT,EAAIW,IAGzBD,EAAAA,EAAUE,KAAK,IAIvBC,IAAAA,EAAYpB,EAAiBqB,QAAQC,MAAMC,QAAQN,IAGpC,IAAfG,GAAqBH,EAAUO,SAAS,OAC9BC,EAAAA,EAAkBR,IAErBJ,EAAAA,KAAKO,GAEXf,OAAAA,EAQSU,CAAYX,GAAYA,GACrCsB,KAAAA,YAAYpB,GAMnB,SAASmB,EAAkBR,GAUpB,IADDU,IAAAA,GAAY,EACPpB,EAAI,EAAGA,EAAIU,EAAUT,OAAQD,GAAQ,EAAG,CAC3CqB,IAAAA,EAAgBX,EAAUY,MAAMtB,GAAKU,EAAUY,MAAM,EAAGtB,GAExDoB,IAAc,KADP3B,EAAAA,EAAiBqB,QAAQC,MAAMC,QAAQK,IAGzCD,OAAAA,EAIJA,OAAAA,EAnHTG,KAAKC,iBACH,UACA,SAASC,GACY,UAAfA,EAAIC,KAAK,GACRD,EAAAA,EAAIC,KAAK,IACa,gBAAhBD,EAAIC,KAAK,KACCD,EAAAA,EAAIC,KAAK,GACpBC,QAAAA,IAAI,8BAAgClC,EAAiBmC,OAAOC,SAGxE","file":"CVwebworker.ae0929e1.map","sourceRoot":"..","sourcesContent":["//global var for structure of table\nvar cityIOdataStruct;\n\n//worker listen to web-worker calls\nself.addEventListener(\n  \"message\",\n  function(msg) {\n    if (msg.data[0] == \"pixels\") {\n      CV(msg.data[1]);\n    } else if (msg.data[0] === \"cityIOsetup\") {\n      cityIOdataStruct = msg.data[1];\n      console.log(\"webWorker got settings for \" + cityIOdataStruct.header.name);\n    }\n  },\n  false\n);\n\n/////////////////////////////////////////////////////////////////\n//do CV on image data\nfunction CV(scannedPixels) {\n  //set threshold for unclear color\n  // between black and white\n  let threshold = 5;\n  //reset array\n  let pixColArr = [];\n  //reset types array\n  let typesArray = [];\n  //retun this msg to main thread\n  let webworkerMsg = [];\n\n  //sample 3 pixels [3x3 colors] each time\n  for (let i = 0; i < scannedPixels.length; i++) {\n    avg_0 =\n      0.21 * scannedPixels[i][0] +\n      0.72 * scannedPixels[i][1] +\n      0.07 * scannedPixels[i][2];\n    avg_1 =\n      0.21 * scannedPixels[i][3] +\n      0.72 * scannedPixels[i][4] +\n      0.07 * scannedPixels[i][5];\n    avg_2 =\n      0.21 * scannedPixels[i][6] +\n      0.72 * scannedPixels[i][7] +\n      0.07 * scannedPixels[i][8];\n\n    avg = (avg_0 + avg_1 + avg_2) / 3;\n    // decide if pixel color should be black or white\n    //based on avg function\n    if (avg > 256 / 2 + threshold) {\n      //black\n      pixelCol = 0;\n    } else if (avg < 256 / 2 - threshold) {\n      //white\n      pixelCol = 1;\n    } else {\n      //3rd color\n      pixelCol = 2;\n    }\n    pixColArr.push(pixelCol);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n\n  function typesLookup(pixelColorArray) {\n    // find this brick's type using the found color info\n    // by matching the 16[4x4] pixels to known types\n    // by running through the 1D list of colors\n    for (let i = 0; i < pixColArr.length; i = i + 16) {\n      let thisBrick = [];\n      for (let j = 0; j < 16; j++) {\n        thisBrick.push(pixelColorArray[i + j]);\n      }\n      //remove new lines and commas to get a clear list\n      thisBrick = thisBrick.join(\"\");\n\n      //before sending back to main thread for cityIO POST,\n      //look for this bricks pattern in 'Codes' property\n      let indexCode = cityIOdataStruct.objects.codes.indexOf(thisBrick);\n      //check if this type is not known\n      //and not becouse it has '2' color\n      if (indexCode === -1 && !thisBrick.includes(\"2\")) {\n        indexCode = checkRotatedBrick(thisBrick);\n      }\n      typesArray.push(indexCode);\n    }\n    return typesArray;\n  }\n\n  /////////////////////////////////////////////////////////////////\n  //send back the location of this type in the types list\n  //return 2 msgs  to main thread:\n  // 1. the type found in cv\n  // 2. colors for  visualization & cityIO sending\n  webworkerMsg.push(typesLookup(pixColArr), pixColArr);\n  self.postMessage(webworkerMsg);\n}\n\n/////////////////////////////////////////////////////////////////\n// checks if this brick string is actually a rotated brick\n\nfunction checkRotatedBrick(thisBrick) {\n  /*\nFor 1110111111111111, check:\n 0  \"1110 1111 1111 1111\"\n 4  \"1111 1111 1111 1110\"\n 8  \"1111 1111 1110 1111\"\n 12 \"1111 1110 1111 1111\"\n*/\n\n  let newIndex = -1;\n  for (let i = 0; i < thisBrick.length; i = i + 4) {\n    var shiftedString = thisBrick.slice(i) + thisBrick.slice(0, i);\n    newIndex = cityIOdataStruct.objects.codes.indexOf(shiftedString);\n    if (newIndex !== -1) {\n      // console.log(\"Rotated, new index: \", newIndex);\n      return newIndex;\n    }\n  }\n  // console.log(newIndex);\n  return newIndex;\n}\n"]}