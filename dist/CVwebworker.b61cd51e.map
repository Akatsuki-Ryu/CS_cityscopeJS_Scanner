{"version":3,"sources":["js/CV/CVwebworker.js"],"names":["cityIOdataStruct","CV","scannedPixels","threshold","pixColArr","typesArray","webworkerMsg","i","length","avg_0","avg_1","avg_2","avg","push","pixelCol","typesLookup","pixelColorArray","thisBrick","j","join","objects","codes","indexOf","postMessage","self","addEventListener","msg","data","log","header","name"],"mappings":";AACA,IAAIA,EAkBJ,SAASC,EAAGC,GAYL,IATDC,IAEAC,EAAY,GAEZC,EAAa,GAEbC,EAAe,GAGVC,EAAI,EAAGA,EAAIL,EAAcM,OAAQD,IAEtC,MAAA,IAAOL,EAAcK,GAAG,GACxB,IAAOL,EAAcK,GAAG,GACxB,IAAOL,EAAcK,GAAG,GAExB,MAAA,IAAOL,EAAcK,GAAG,GACxB,IAAOL,EAAcK,GAAG,GACxB,IAAOL,EAAcK,GAAG,GAExB,MAAA,IAAOL,EAAcK,GAAG,GACxB,IAAOL,EAAcK,GAAG,GACxB,IAAOL,EAAcK,GAAG,GAEpB,KAACE,MAAQC,MAAQC,OAAS,EAG5BC,IAAM,IAEG,SAAA,EACFA,IAAM,IAEJ,SAAA,EAGA,SAAA,EAEHC,EAAAA,KAAKC,UA6BJD,EAAAA,KAxBJE,SAAYC,GAId,IAAA,IAAIT,EAAI,EAAGA,EAAIH,EAAUI,OAAQD,GAAQ,GAAI,CAE3C,IADDU,IAAAA,EAAY,GACPC,EAAI,EAAGA,EAAI,GAAIA,IACZL,EAAAA,KAAKG,EAAgBT,EAAIW,IAGzBD,EAAAA,EAAUE,KAAK,IAGhBN,EAAAA,KAAKb,EAAiBoB,QAAQC,MAAMC,QAAQL,IAElDZ,OAAAA,EASSU,CAAYX,GAAYA,GACrCmB,KAAAA,YAAYjB,GApFnBkB,KAAKC,iBACH,UACA,SAASC,GACY,UAAfA,EAAIC,KAAK,GACRD,EAAAA,EAAIC,KAAK,IACa,gBAAhBD,EAAIC,KAAK,KACCD,EAAAA,EAAIC,KAAK,GACpBC,QAAAA,IAAI,8BAAgC5B,EAAiB6B,OAAOC,SAGxE","file":"CVwebworker.b61cd51e.map","sourceRoot":"..","sourcesContent":["//global var for structure of table\nvar cityIOdataStruct;\n\n//worker listen to web-worker calls\nself.addEventListener(\n  \"message\",\n  function(msg) {\n    if (msg.data[0] == \"pixels\") {\n      CV(msg.data[1]);\n    } else if (msg.data[0] === \"cityIOsetup\") {\n      cityIOdataStruct = msg.data[1];\n      console.log(\"webWorker got settings for \" + cityIOdataStruct.header.name);\n    }\n  },\n  false\n);\n\n/////////////////////////////////////////////////////////////////\n//do CV on image data\nfunction CV(scannedPixels) {\n  //set threshold for unclear color\n  // between black and white\n  let threshold = 5;\n  //reset array\n  let pixColArr = [];\n  //reset types array\n  let typesArray = [];\n  //retun this msg to main thread\n  let webworkerMsg = [];\n\n  //sample 3 pixels [3x3 colors] each time\n  for (let i = 0; i < scannedPixels.length; i++) {\n    avg_0 =\n      0.21 * scannedPixels[i][0] +\n      0.72 * scannedPixels[i][1] +\n      0.07 * scannedPixels[i][2];\n    avg_1 =\n      0.21 * scannedPixels[i][3] +\n      0.72 * scannedPixels[i][4] +\n      0.07 * scannedPixels[i][5];\n    avg_2 =\n      0.21 * scannedPixels[i][6] +\n      0.72 * scannedPixels[i][7] +\n      0.07 * scannedPixels[i][8];\n\n    avg = (avg_0 + avg_1 + avg_2) / 3;\n    // decide if pixel color should be black or white\n    //based on avg function\n    if (avg > 256 / 2 + threshold) {\n      //black\n      pixelCol = 0;\n    } else if (avg < 256 / 2 - threshold) {\n      //white\n      pixelCol = 1;\n    } else {\n      //3rd color\n      pixelCol = 2;\n    }\n    pixColArr.push(pixelCol);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n\n  function typesLookup(pixelColorArray) {\n    // find this brick's type using the found color info\n    // by matching the 16[4x4] pixels to known types\n    // by running through the 1D list of colors\n    for (let i = 0; i < pixColArr.length; i = i + 16) {\n      let thisBrick = [];\n      for (let j = 0; j < 16; j++) {\n        thisBrick.push(pixelColorArray[i + j]);\n      }\n      //remove  new lines and commas for clear list\n      thisBrick = thisBrick.join(\"\");\n      //before sending back to main thread for cityIO POST,\n      //look for this bricks pattern in 'Codes' property\n      typesArray.push(cityIOdataStruct.objects.codes.indexOf(thisBrick));\n    }\n    return typesArray;\n  }\n\n  /////////////////////////////////////////////////////////////////\n  //send back the location of this type in the types list\n\n  //return 2 msgs  to main thread:\n  // 1. the type found in cv\n  // 2. colors for  visualization & cityIO sending\n  webworkerMsg.push(typesLookup(pixColArr), pixColArr);\n  self.postMessage(webworkerMsg);\n}\n"]}