{"version":3,"sources":["js/CV/CVwebworker.js"],"names":["cityIOdataStruct","CV","scannedPixels","threshold","pixColArr","typesArray","webworkerMsg","i","length","avg_0","avg_1","avg_2","avg","push","pixelCol","typesLookup","pixelColorArray","thisBrick","j","join","indexCode","objects","codes","indexOf","includes","checkRotatedBrick","postMessage","arrBrick","Array","from","slice","brickCCW270","rotMtrxCCW","toString","replace","brickCCW180","brickCCW90","self","addEventListener","msg","data","log","header","name","flipMatrix","matrix","map","column","index","row","reverse"],"mappings":";AACA,IAAIA,EAkBJ,SAASC,EAAGC,GAYL,IATDC,IAEAC,EAAY,GAEZC,EAAa,GAEbC,EAAe,GAGVC,EAAI,EAAGA,EAAIL,EAAcM,OAAQD,IAEtC,MAAA,IAAOL,EAAcK,GAAG,GACxB,IAAOL,EAAcK,GAAG,GACxB,IAAOL,EAAcK,GAAG,GAExB,MAAA,IAAOL,EAAcK,GAAG,GACxB,IAAOL,EAAcK,GAAG,GACxB,IAAOL,EAAcK,GAAG,GAExB,MAAA,IAAOL,EAAcK,GAAG,GACxB,IAAOL,EAAcK,GAAG,GACxB,IAAOL,EAAcK,GAAG,GAEpB,KAACE,MAAQC,MAAQC,OAAS,EAG5BC,IAAM,IAEG,SAAA,EACFA,IAAM,IAEJ,SAAA,EAGA,SAAA,EAEHC,EAAAA,KAAKC,UAsCJD,EAAAA,KAjCJE,SAAYC,GAId,IAAA,IAAIT,EAAI,EAAGA,EAAIH,EAAUI,OAAQD,GAAQ,GAAI,CAE3C,IADDU,IAAAA,EAAY,GACPC,EAAI,EAAGA,EAAI,GAAIA,IACZL,EAAAA,KAAKG,EAAgBT,EAAIW,IAGzBD,EAAAA,EAAUE,KAAK,IAIvBC,IAAAA,EAAYpB,EAAiBqB,QAAQC,MAAMC,QAAQN,IAGpC,IAAfG,GAAqBH,EAAUO,SAAS,OAC9BC,EAAAA,EACVR,EACAjB,EAAiBqB,QAAQC,QAGlBT,EAAAA,KAAKO,GAEXf,OAAAA,EAQSU,CAAYX,GAAYA,GACrCsB,KAAAA,YAAYpB,GAKnB,SAASmB,EAAkBR,EAAWK,GAOhCK,IAAAA,EAAW,EALHC,EAAAA,MAAMC,KAAKZ,IAMXa,MAAM,EAAG,GACnBb,EAAUa,MAAM,EAAG,GACnBb,EAAUa,MAAM,EAAG,IACnBb,EAAUa,MAAM,GAAI,KAIlBC,EAAcC,EAAWL,GAC1BM,WACAC,QAAQ,KAAM,IAGbd,EAAYE,EAAMC,QAAQQ,GAE1BX,IAAe,IAAfA,EAIKA,OAAAA,EAIHe,IAAAA,EAAcH,EAAWA,EAAWL,IACrCM,WACAC,QAAQ,KAAM,IAGbd,EAAYE,EAAMC,QAAQY,GAC1Bf,IAAe,IAAfA,EAIKA,OAAAA,EAIHgB,IAAAA,EAAaJ,EAAWA,EAAWA,EAAWL,KAC/CM,WACAC,QAAQ,KAAM,IAGbd,EAAYE,EAAMC,QAAQa,GAE1BhB,OAAe,IAAfA,EAIKA,GAEM,EA3JrBiB,KAAKC,iBACH,UACA,SAASC,GACY,UAAfA,EAAIC,KAAK,GACRD,EAAAA,EAAIC,KAAK,IACa,gBAAhBD,EAAIC,KAAK,KACCD,EAAAA,EAAIC,KAAK,GACpBC,QAAAA,IAAI,8BAAgCzC,EAAiB0C,OAAOC,SAGxE,GAuJF,IAAMC,EAAa,SAAA,GACjBC,OAAAA,EAAO,GAAGC,IAAI,SAACC,EAAQC,GAAUH,OAAAA,EAAOC,IAAI,SAAA,GAAOG,OAAAA,EAAID,QACnDhB,EAAa,SAAA,GAAUY,OAAAA,EAAWC,GAAQK","file":"CVwebworker.af2e9e65.map","sourceRoot":"..","sourcesContent":["//global var for structure of table\nvar cityIOdataStruct;\n\n//worker listen to web-worker calls\nself.addEventListener(\n  \"message\",\n  function(msg) {\n    if (msg.data[0] == \"pixels\") {\n      CV(msg.data[1]);\n    } else if (msg.data[0] === \"cityIOsetup\") {\n      cityIOdataStruct = msg.data[1];\n      console.log(\"webWorker got settings for \" + cityIOdataStruct.header.name);\n    }\n  },\n  false\n);\n\n/////////////////////////////////////////////////////////////////\n//do CV on image data\nfunction CV(scannedPixels) {\n  //set threshold for unclear color\n  // between black and white\n  let threshold = 5;\n  //reset array\n  let pixColArr = [];\n  //reset types array\n  let typesArray = [];\n  //retun this msg to main thread\n  let webworkerMsg = [];\n\n  //sample 3 pixels [3x3 colors] each time\n  for (let i = 0; i < scannedPixels.length; i++) {\n    avg_0 =\n      0.21 * scannedPixels[i][0] +\n      0.72 * scannedPixels[i][1] +\n      0.07 * scannedPixels[i][2];\n    avg_1 =\n      0.21 * scannedPixels[i][3] +\n      0.72 * scannedPixels[i][4] +\n      0.07 * scannedPixels[i][5];\n    avg_2 =\n      0.21 * scannedPixels[i][6] +\n      0.72 * scannedPixels[i][7] +\n      0.07 * scannedPixels[i][8];\n\n    avg = (avg_0 + avg_1 + avg_2) / 3;\n    // decide if pixel color should be black or white\n    //based on avg function\n    if (avg > 256 / 2 + threshold) {\n      //black\n      pixelCol = 0;\n    } else if (avg < 256 / 2 - threshold) {\n      //white\n      pixelCol = 1;\n    } else {\n      //3rd color\n      pixelCol = 2;\n    }\n    pixColArr.push(pixelCol);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n\n  function typesLookup(pixelColorArray) {\n    // find this brick's type using the found color info\n    // by matching the 16[4x4] pixels to known types\n    // by running through the 1D list of colors\n    for (let i = 0; i < pixColArr.length; i = i + 16) {\n      let thisBrick = [];\n      for (let j = 0; j < 16; j++) {\n        thisBrick.push(pixelColorArray[i + j]);\n      }\n      //remove new lines and commas to get a clear list\n      thisBrick = thisBrick.join(\"\");\n\n      //before sending back to main thread for cityIO POST,\n      //look for this bricks pattern in 'Codes' property\n      let indexCode = cityIOdataStruct.objects.codes.indexOf(thisBrick);\n      //check if this type is not known\n      //and not becouse it has '2' color\n      if (indexCode === -1 && !thisBrick.includes(\"2\")) {\n        indexCode = checkRotatedBrick(\n          thisBrick,\n          cityIOdataStruct.objects.codes\n        );\n      }\n      typesArray.push(indexCode);\n    }\n    return typesArray;\n  }\n\n  /////////////////////////////////////////////////////////////////\n  //send back the location of this type in the types list\n  //return 2 msgs  to main thread:\n  // 1. the type found in cv\n  // 2. colors for  visualization & cityIO sending\n  webworkerMsg.push(typesLookup(pixColArr), pixColArr);\n  self.postMessage(webworkerMsg);\n}\n\n/////////////////////////////////////////////////////////////////\n\nfunction checkRotatedBrick(thisBrick, codes) {\n  //convert this brick  string to array\n  thisBrick = Array.from(thisBrick);\n\n  // console.log(\"-----------NEW BRICK-----------\");\n\n  //convert the array to 2 matrix of 4 arrays\n  let arrBrick = [\n    thisBrick.slice(0, 4),\n    thisBrick.slice(4, 8),\n    thisBrick.slice(8, 12),\n    thisBrick.slice(12, 16)\n  ];\n  //rotate this matrix 90 deg CCW [left]\n  // and convert back to string\n  let brickCCW270 = rotMtrxCCW(arrBrick)\n    .toString()\n    .replace(/,/g, \"\");\n  // console.log(\"270 \", brickCCW270);\n  //check the brick aginst the codes array\n  let indexCode = codes.indexOf(brickCCW270);\n  //if brick is a type in codes\n  if (indexCode !== -1) {\n    //return it\n    // console.log(indexCode);\n\n    return indexCode;\n    //if brick is not a type in codes\n  } else {\n    //rotate it again\n    let brickCCW180 = rotMtrxCCW(rotMtrxCCW(arrBrick))\n      .toString()\n      .replace(/,/g, \"\");\n    // console.log(\"180\", brickCCW180);\n    //check the brick aginst the codes array\n    let indexCode = codes.indexOf(brickCCW180);\n    if (indexCode !== -1) {\n      //return it\n      // console.log(indexCode);\n\n      return indexCode;\n      //if brick is not a type in codes\n    } else {\n      //rotate it again\n      let brickCCW90 = rotMtrxCCW(rotMtrxCCW(rotMtrxCCW(arrBrick)))\n        .toString()\n        .replace(/,/g, \"\");\n      // console.log(\"90\", brickCCW90);\n      //check the brick aginst the codes array\n      let indexCode = codes.indexOf(brickCCW90);\n      //\n      if (indexCode !== -1) {\n        //return it\n        // console.log(indexCode);\n\n        return indexCode;\n        //conclude that this is not a type\n      } else return -1;\n    }\n  }\n}\n\n// filp function\nconst flipMatrix = matrix =>\n  matrix[0].map((column, index) => matrix.map(row => row[index]));\nconst rotMtrxCCW = matrix => flipMatrix(matrix).reverse();\n"]}